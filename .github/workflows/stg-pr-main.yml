name: stg-pr-main

on:
  workflow_call:
    inputs:
      issue_body:
        type: string
        required: true
      issue_number:
        type: string
        required: true
      issue_opener:
        type: string
        required: true
      repository:            # owner/repo of the target repo
        type: string
        required: true
      slack_channel:
        type: string
        required: false
        default: ""
      target_branch:         # PR will be opened against this branch (was 'main')
        type: string
        required: false
        default: "main"
    secrets:
      slack_bot_token:
        required: false

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: release-issue-${{ inputs.issue_number }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          repository: ${{ inputs.repository }}

      - name: Configure git
        run: |
          git config user.name  "release-bot"
          git config user.email "release-bot@users.noreply.github.com"

      - name: Read and validate form values (fail if missing)
        id: form
        env:
          ISSUE_BODY:  ${{ inputs.issue_body }}
          ISSUE_OPENER: ${{ inputs.issue_opener }}
        run: |
          set -euo pipefail
          BODY="$RUNNER_TEMP/body.txt"
          printf '%s\n' "$ISSUE_BODY" > "$BODY"

          # Title from Issue (single line)
          TITLE=$(jq -r '.issue.title' "$GITHUB_EVENT_PATH" | tr -d '\r' | head -n1)

          # helpers to extract fields from the Issue Form body
          get_field () {
            awk -v prefix="$1" 'BEGIN{flag=0}
              /^###[[:space:]]/{
                line=$0; sub(/^###[[:space:]]*/,"",line)
                flag=(index(line,prefix)==1); next
              }
              flag { print }
            ' "$BODY" | sed '/^[[:space:]]*$/d' | head -n1 | xargs
          }
          get_section_lines () {
            awk -v prefix="$1" 'BEGIN{flag=0}
              /^###[[:space:]]/{
                line=$0; sub(/^###[[:space:]]*/,"",line)
                flag=(index(line,prefix)==1); next
              }
              flag { print }
            ' "$BODY" | sed '/^[[:space:]]*$/d'
          }

          GH_USERNAME=$(get_field "GitHub username")
          BASE=$(get_field "Base PRs branch (e.g. staging)")
          STATE=$(get_field "PR status")
          DAYS_BACK=$(get_field "Lookback window (days)")
          SKIP_LABEL=$(get_field "Prod Hold (label name)")   # <- comes from your Issue Form (value: "skip-prod")
          SLACK_CC=$(get_section_lines "Reviewer" | sed 's/^- *//' | paste -sd' ' - || true)

          EXTRA=$(
            get_section_lines "Extra PR numbers or URLs to include (optional)" \
            | sed 's#.*/pull/##' | sed 's/[^0-9].*$//' | grep -E '^[0-9]+$' || true
          )

          # Required fields (including the skip label from the form)
          for var in GH_USERNAME BASE STATE DAYS_BACK SKIP_LABEL; do
            eval v=\$$var
            [ -n "$v" ] || { echo "::error::$var is required in the issue form"; exit 1; }
          done

          if [ "$ISSUE_OPENER" != "$GH_USERNAME" ]; then
            echo "::error::Issue opener ($ISSUE_OPENER) must match GH username ($GH_USERNAME)"; exit 1
          fi

          {
            echo "GH_USERNAME=$GH_USERNAME"
            echo "BASE=$BASE"
            echo "STATE=$STATE"
            echo "DAYS_BACK=$DAYS_BACK"
            echo "SLACK_CC=$SLACK_CC"
            echo "EXTRA=$(echo "$EXTRA" | paste -sd, -)"
            echo "TITLE=$TITLE"
            echo "SKIP_LABEL=$SKIP_LABEL"
          } >> "$GITHUB_OUTPUT"

      - name: Find PRs by author/base/state updated within days_back
        id: find
        env:
          GH_TOKEN:     ${{ github.token }}
          REPO:         ${{ inputs.repository }}
          GH_USERNAME:  ${{ steps.form.outputs.GH_USERNAME }}
          BASE:         ${{ steps.form.outputs.BASE }}
          STATE:        ${{ steps.form.outputs.STATE }}
          DAYS:         ${{ steps.form.outputs.DAYS_BACK }}
        run: |
          set -euo pipefail
          SINCE=$(date -u -d "-${DAYS:-14} days" +%Y-%m-%d)
          CAND=$(gh pr list --repo "$REPO" \
                             --author "$GH_USERNAME" \
                             --base "$BASE" \
                             --state "$STATE" \
                             --search "updated:>=$SINCE" \
                             --json number --jq '.[].number' || true)
          [ -n "${CAND:-}" ] || { echo "::error::No PRs found for author=$GH_USERNAME base=$BASE state=$STATE updated:>=$SINCE"; exit 1; }
          PRS=$(printf '%s\n' $CAND | sort -u | paste -sd, -)
          echo "PRS=$PRS" >> "$GITHUB_OUTPUT"

      - name: Combine with any extra PRs
        id: combine
        run: |
          A="${{ steps.find.outputs.PRS }}"
          B="${{ steps.form.outputs.EXTRA }}"
          LIST=$(printf "%s\n%s\n" "$A" "$B" | tr ',' '\n' | grep -E '^[0-9]+$' | sort -u | paste -sd, -)
          [ -n "$LIST" ] || { echo "::error::No PRs to include after combining."; exit 1; }
          echo "PR_LIST=$LIST" >> "$GITHUB_OUTPUT"
          echo "Including: $LIST"

      - name: Create release branch from selected base
        id: mk
        run: |
          set -euo pipefail
          USER_SLUG='${{ inputs.issue_opener }}'
          BR="${USER_SLUG}/${{ github.run_id }}-${{ github.run_attempt }}"
          BASE='${{ steps.form.outputs.BASE }}'
          git fetch origin "$BASE"
          git switch -c "$BR" "origin/$BASE"
          echo "BRANCH=$BR"  >> "$GITHUB_OUTPUT"
          echo "BASE=$BASE"  >> "$GITHUB_OUTPUT"

      - name: Preflight — fail if any PR conflicts
        id: preflight
        env:
          GH_TOKEN: ${{ github.token }}
          PRS:      ${{ steps.combine.outputs.PR_LIST }}
          REPO:     ${{ inputs.repository }}
        run: |
          set -euo pipefail
          BLOCKERS=()
          IFS=, read -ra arr <<< "$PRS"
          for PR in "${arr[@]}"; do
            PR=$(echo "$PR" | xargs)
            git reset --hard
            git fetch --no-tags origin "pull/$PR/head:pr-$PR"
            
            if ! git merge --no-commit --squash "pr-$PR" >/dev/null 2>&1; then
              echo "::error::Would conflict when applying PR #$PR"
              BLOCKERS+=("$PR")
              git merge --abort || git reset --merge || git reset --hard
            else
              git reset --hard
            fi
            git branch -D "pr-$PR" || true
          done
          if [ ${#BLOCKERS[@]} -gt 0 ]; then
            echo "blockers=$(IFS=,; echo "${BLOCKERS[*]}")" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Notify blockers to rebase
        if: ${{ steps.preflight.outcome == 'failure' && steps.preflight.outputs.blockers != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          REPO:     ${{ inputs.repository }}
          BASE:     ${{ steps.form.outputs.BASE }}
        run: |
          set -euo pipefail
          IFS=, read -ra arr <<< "${{ steps.preflight.outputs.blockers }}"
          for PR in "${arr[@]}"; do
            PR=$(echo "$PR" | xargs)
            gh pr comment "$PR" --repo "$REPO" --body "This PR conflicts with the release build. Please update your branch to \`$BASE\` and push again."
          done

      - name: Merge selected PRs (squash commits; fail on conflict)
        id: merge
        if: ${{ steps.preflight.outcome == 'success' }}
        env:
          GH_TOKEN:      ${{ github.token }}
          PRS:           ${{ steps.combine.outputs.PR_LIST }}
          BASE:          ${{ steps.form.outputs.BASE }}
          REPO:          ${{ inputs.repository }}
          EXCLUDE_LABEL: ${{ steps.form.outputs.SKIP_LABEL }}   # e.g. "skip-prod" from Issue Form
          TARGET:        ${{ inputs.target_branch }}
        run: |
          set -euo pipefail

          # Always exclude any PR that carries the skip label when building the prod release PR.
          IFS=, read -ra arr <<< "$PRS"
          for PR in "${arr[@]}"; do
            PR=$(echo "$PR" | xargs)

            # Skip any PR carrying the exclusion label (case-insensitive)
            if gh pr view "$PR" --repo "$REPO" --json labels --jq \
               ".labels[].name | ascii_downcase" | grep -xqi "$(echo "$EXCLUDE_LABEL" | tr '[:upper:]' '[:lower:]')"; then
              echo "Skipping PR #$PR (has label '$EXCLUDE_LABEL')."
              continue
            fi

            BASE_REF=$(gh pr view "$PR" --repo "$REPO" --json baseRefName --jq .baseRefName)
            if [ "$BASE_REF" != "$BASE" ]; then
              echo "::error::PR #$PR targets '$BASE_REF' but you selected base '$BASE'."; exit 1
            fi

            TITLE=$(gh pr view "$PR" --repo "$REPO" --json title --jq .title)
            echo "Including PR #$PR — $TITLE"

            git fetch --no-tags origin "pull/$PR/head:pr-$PR"
            git merge --squash "pr-$PR" || {
              echo "::error::Merge conflicts while squashing PR #$PR"
              git merge --abort || git reset --merge || git reset --hard
              exit 1
            }

            if git diff --cached --quiet; then
              echo "No changes from PR #$PR (already on base)."
              git reset
            else
              git commit -m "Include PR #$PR: $TITLE"
            fi
            git branch -D "pr-$PR" || true
          done

          # detect if anything differs from target branch
          if git fetch origin ${{ inputs.target_branch }}:${{ inputs.target_branch }} && git diff --quiet origin/${{ inputs.target_branch }}..HEAD; then
            echo "HAS_CHANGES=false" >> "$GITHUB_OUTPUT"
          else
            echo "HAS_CHANGES=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Push release branch and open PR to target
        if: ${{ steps.merge.outputs.HAS_CHANGES == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          BRANCH:   ${{ steps.mk.outputs.BRANCH }}
          REPO:     ${{ inputs.repository }}
          TITLE:    ${{ steps.form.outputs.TITLE }}
          BASE:     ${{ steps.form.outputs.BASE }}
          DAYS:     ${{ steps.form.outputs.DAYS_BACK }}
          GH_USER:  ${{ steps.form.outputs.GH_USERNAME }}
          TARGET:   ${{ inputs.target_branch }}
        run: |
          set -euo pipefail
          git push -u origin "$BRANCH"
          EXIST=$(gh pr list --repo "$REPO" --head "$BRANCH" --state all --json number --jq '.[0].number' || true)
          if [ -z "${EXIST:-}" ]; then
            gh pr create --repo "$REPO" --base "$TARGET" --head "$BRANCH" \
              --title "$TITLE" \
              --body "Author: @$GH_USER | Base: \`$BASE\` | Lookback: \`$DAYS\` days"
          fi

      - name: Get PR info
        id: pr
        if: ${{ steps.merge.outputs.HAS_CHANGES == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          BRANCH:   ${{ steps.mk.outputs.BRANCH }}
          REPO:     ${{ inputs.repository }}
        run: |
          set -euo pipefail
          j=$(gh pr list --repo "$REPO" --head "$BRANCH" --state all --json number,url,title,baseRefName,headRefName,author --jq '.[0]')
          [ -n "$j" ] && [ "$j" != "null" ] || { echo "::error::No PR found for head $BRANCH"; exit 1; }
          echo "number=$(jq -r .number <<<"$j")"       >> "$GITHUB_OUTPUT"
          echo "url=$(jq -r .url <<<"$j")"             >> "$GITHUB_OUTPUT"
          echo "title=$(jq -r .title <<<"$j")"         >> "$GITHUB_OUTPUT"
          echo "base=$(jq -r .baseRefName <<<"$j")"    >> "$GITHUB_OUTPUT"
          echo "head=$(jq -r .headRefName <<<"$j")"    >> "$GITHUB_OUTPUT"
          echo "author=$(jq -r .author.login <<<"$j")" >> "$GITHUB_OUTPUT"

      - name: Notify Slack via bot (optional)
        if: ${{ steps.merge.outputs.HAS_CHANGES == 'true' && steps.pr.outputs.base == inputs.target_branch }}
        uses: slackapi/slack-github-action@v1
        with:
          channel-id: ${{ inputs.slack_channel }}
          payload: |
            {
              "unfurl_links": false, "unfurl_media": false,
              "text": "Release PR needs approval — ${{ steps.form.outputs.TITLE }}",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "${{ steps.form.outputs.TITLE }}", "emoji": true } },
                { "type": "section", "text": { "type": "mrkdwn",
                  "text": "*Repo:* ${{ github.repository }}\n*Author:* @${{ steps.form.outputs.GH_USERNAME }}\n*PR:* <${{ steps.pr.outputs.url }}|#${{ steps.pr.outputs.number }} — ${{ steps.form.outputs.TITLE }}>\n*Target branch:* ${{ steps.pr.outputs.base }}\n*Filter:* Author: @${{ steps.form.outputs.GH_USERNAME }} | Base: ${{ steps.form.outputs.BASE }} | Lookback: ${{ steps.form.outputs.DAYS_BACK }} days"
                }},
                { "type": "context", "elements": [
                  { "type": "mrkdwn", "text": "cc: ${{ steps.form.outputs.SLACK_CC }}" }
                ]},
                { "type": "actions", "elements": [
                  { "type": "button", "text": { "type": "plain_text", "text": "Open PR" }, "url": "${{ steps.pr.outputs.url }}", "style": "primary" }
                ]}
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.slack_bot_token }}

      - name: Close the release request issue
        if: ${{ steps.merge.outputs.HAS_CHANGES == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue close ${{ inputs.issue_number }} --repo ${{ inputs.repository }} \
            --comment "Closed by release workflow. Opened PR: ${{ steps.pr.outputs.url }}"

      - name: Cleanup release branch
        if: ${{ steps.merge.outputs.HAS_CHANGES == 'true' }}
        env:
          PRS: ${{ steps.combine.outputs.PR_LIST }}
        run: |
          set -euo pipefail
          [ -z "${PRS:-}" ] && { echo "No PRs to clean."; exit 0; }

          echo "Cleaning PRs: $PRS"
          for P in ${PRS//,/ }; do
            echo "Deleting refs for PR #$P"
            git branch -D "pr-$P"       2>/dev/null || true
            git update-ref -d "refs/pull/$P/head" 2>/dev/null || true
            git update-ref -d "refs/remotes/origin/pull/$P/head" 2>/dev/null || true
          done

          git remote prune origin || true
          git gc --prune=now --aggressive || true
