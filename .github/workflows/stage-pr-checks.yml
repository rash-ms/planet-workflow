name: stage-pr-checks

on:
  workflow_call:
    inputs:
      base_branch:         # the PR target env branch (e.g., staging, preprod)
        type: string
        default: "staging"
      trunk_branch:        # your source-of-truth branch (e.g., main, develop)
        type: string
        default: "main"
      pr_head:             # feature branch name (e.g., feature/foo)
        type: string
        required: true
      pr_number:           # PR number (pass from caller)
        type: string
        required: true
      repository:          # owner/repo (pass from caller)
        type: string
        required: true
    secrets: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  gate:
    runs-on: ubuntu-latest
    concurrency:
      # serialize per PR to avoid races
      group: gate-${{ inputs.repository }}-${{ inputs.pr_number }}
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.pr_head }}   # operate on the PR head branch

      - name: Configure git
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Validate remote branches exist
        run: |
          set -e
          for BR in "${{ inputs.trunk_branch }}" "${{ inputs.base_branch }}"; do
            git ls-remote --exit-code origin "refs/heads/$BR" >/dev/null || {
              echo "::error::Branch '$BR' not found on origin."; exit 1; }
          done

      # üîí Hard rule: staging must already include main (kept in a separate sync workflow)
      - name: Assert base contains trunk
        shell: bash
        env:
          TRUNK: ${{ inputs.trunk_branch }}
          BASE:  ${{ inputs.base_branch }}
        run: |
          set -euo pipefail

          # Clean up any mistaken local branches called origin/<name> from older runs
          git show-ref --verify --quiet "refs/heads/origin/$TRUNK" && git branch -D "origin/$TRUNK"
          git show-ref --verify --quiet "refs/heads/origin/$BASE"  && git branch -D "origin/$BASE"

          # Fetch remote-tracking refs normally
          git fetch --prune --no-tags origin

          MAIN_REF="refs/remotes/origin/$TRUNK"
          BASE_REF="refs/remotes/origin/$BASE"

          # Sanity check the refs exist
          git show-ref --verify --quiet "$MAIN_REF" || { echo "::error::Missing $MAIN_REF"; exit 1; }
          git show-ref --verify --quiet "$BASE_REF" || { echo "::error::Missing $BASE_REF"; exit 1; }

          # Hard rule: base must already include trunk (main ‚äÜ staging)
          if ! git merge-base --is-ancestor "$MAIN_REF" "$BASE_REF"; then
            echo "::error::$BASE is behind $TRUNK. Run/merge the $TRUNK‚Üí$BASE sync first."
            exit 1
          fi


      # ‚úÖ Bring latest staging into the PR head (or fail fast if conflicts)
      # - name: Ensure PR head contains base
      #   env:
      #     HEAD_REF: ${{ inputs.pr_head }}
      #   run: |
      #     set -euo pipefail
      #     git fetch origin +refs/heads/${{ inputs.base_branch }}:origin/${{ inputs.base_branch }}
      #     if ! git merge-base --is-ancestor origin/${{ inputs.base_branch }} HEAD; then
      #       git merge --no-ff --no-edit origin/${{ inputs.base_branch }} || {
      #         echo "::error::Conflicts merging ${{ inputs.base_branch }} into ${HEAD_REF}. Please rebase/merge locally and push.";
      #         exit 1
      #       }
      #       # Same-repo PRs can be auto-updated; forks may reject this push
      #       git push origin "HEAD:${HEAD_REF}" || true
      #     fi

      - name: Ensure PR head contains base
        shell: bash
        env:
          HEAD_REF: ${{ inputs.pr_head }}
          BASE:     ${{ inputs.base_branch }}
        run: |
          set -euo pipefail

          # We should already be checked out to the PR head (set ref: in checkout step)
          # Clean up any mistaken local heads called origin/<base>
          if git show-ref --verify --quiet "refs/heads/origin/$BASE"; then
            git branch -D "origin/$BASE"
          fi

          # Refresh remote-tracking refs
          git fetch --prune --no-tags origin

          BASE_REF="refs/remotes/origin/$BASE"

          # Sanity check
          git show-ref --verify --quiet "$BASE_REF" || { echo "::error::Missing $BASE_REF"; exit 1; }

          # If PR head doesn't already contain latest base, try to merge it
          if ! git merge-base --is-ancestor "$BASE_REF" HEAD; then
            git merge --no-ff --no-edit "$BASE_REF" || {
              echo "::error::Conflicts merging $BASE into $HEAD_REF. Please rebase/merge locally and push.";
              exit 1
            }
            # Same-repo PRs can be auto-updated; forks may reject this push (that's OK)
            git push origin "HEAD:${HEAD_REF}" || true
          fi


      # üõ°Ô∏è Preflight: will this PR apply cleanly to main during release?
      - name: Preflight against trunk (main/develop)
        env:
          PR: ${{ inputs.pr_number }}
          TRUNK: ${{ inputs.trunk_branch }}
        shell: bash
        run: |
          set -euo pipefail

          # Clean up any mistaken local branches called origin/<name>
          if git show-ref --verify --quiet "refs/heads/origin/$TRUNK"; then
            git branch -D "origin/$TRUNK"
          fi

          # Get up-to-date remote-tracking refs
          git fetch --prune --no-tags origin
          git fetch --no-tags origin "pull/$PR/head:pr-$PR"

          MAIN_REF="refs/remotes/origin/$TRUNK"

          # Sanity check
          git show-ref --verify --quiet "$MAIN_REF" || { echo "::error::Missing $MAIN_REF"; exit 1; }

          # Try the merge (non-squash so MERGE_HEAD exists on conflict)
          git switch -c preflight "$MAIN_REF"
          if ! git merge --no-commit "pr-$PR"; then
            echo "::error::This PR won't apply cleanly to '$TRUNK' during release. Rebase on latest staging/main and push again."
            git merge --abort || true
            exit 1
          fi

          # Clean up
          git merge --abort || true
          git branch -D "pr-$PR" || true

