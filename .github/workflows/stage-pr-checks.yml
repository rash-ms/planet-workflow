name: stage-pr-checks

on:
  workflow_call:
    inputs:
      base_branch:         # the PR target env branch (e.g., staging, preprod)
        type: string
        default: "staging"
      trunk_branch:        # your source-of-truth branch (e.g., main, develop)
        type: string
        default: "main"
      pr_head:             # feature branch name (e.g., feature/foo)
        type: string
        required: true
      pr_number:           # PR number (pass from caller)
        type: string
        required: true
      repository:          # owner/repo (pass from caller)
        type: string
        required: true
    secrets: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  gate:
    runs-on: ubuntu-latest
    concurrency:
      # serialize per PR to avoid races
      group: gate-${{ inputs.repository }}-${{ inputs.pr_number }}
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.pr_head }}   # operate on the PR head branch

      - name: Configure git
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Validate remote branches exist
        run: |
          set -e
          for BR in "${{ inputs.trunk_branch }}" "${{ inputs.base_branch }}"; do
            git ls-remote --exit-code origin "refs/heads/$BR" >/dev/null || {
              echo "::error::Branch '$BR' not found on origin."; exit 1; }
          done

      # 🔒 Hard rule: staging must already include main (kept in a separate sync workflow)
      - name: Assert base contains trunk
        run: |
          set -euo pipefail
          git fetch origin +refs/heads/${{ inputs.trunk_branch }}:origin/${{ inputs.trunk_branch }} \
                           +refs/heads/${{ inputs.base_branch }}:origin/${{ inputs.base_branch }}
          if ! git merge-base --is-ancestor origin/${{ inputs.trunk_branch }} origin/${{ inputs.base_branch }}; then
            echo "::error::${{ inputs.base_branch }} is behind ${{ inputs.trunk_branch }}. Run/merge the main→staging sync first."
            exit 1
          fi

      # ✅ Bring latest staging into the PR head (or fail fast if conflicts)
      - name: Ensure PR head contains base
        env:
          HEAD_REF: ${{ inputs.pr_head }}
        run: |
          set -euo pipefail
          git fetch origin +refs/heads/${{ inputs.base_branch }}:origin/${{ inputs.base_branch }}
          if ! git merge-base --is-ancestor origin/${{ inputs.base_branch }} HEAD; then
            git merge --no-ff --no-edit origin/${{ inputs.base_branch }} || {
              echo "::error::Conflicts merging ${{ inputs.base_branch }} into ${HEAD_REF}. Please rebase/merge locally and push.";
              exit 1
            }
            # Same-repo PRs can be auto-updated; forks may reject this push
            git push origin "HEAD:${HEAD_REF}" || true
          fi

      # 🛡️ Preflight: will this PR apply cleanly to main during release?
      - name: Preflight against trunk (main/develop)
        env:
          PR: ${{ inputs.pr_number }}
        run: |
          set -euo pipefail
          git fetch origin pull/$PR/head:pr-$PR +refs/heads/${{ inputs.trunk_branch }}:origin/${{ inputs.trunk_branch }}
          git switch -c preflight origin/${{ inputs.trunk_branch }}
          if ! git merge --no-commit pr-$PR; then
            echo "::error::This PR won't apply cleanly to '${{ inputs.trunk_branch }}' during release. Rebase on latest staging/main and push again."
            exit 1
          fi
          git merge --abort || true
